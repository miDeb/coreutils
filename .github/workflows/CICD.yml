name: CICD

# spell-checker:ignore (acronyms) CICD MSVC musl
# spell-checker:ignore (env/flags) Awarnings RUSTDOCFLAGS RUSTFLAGS Zinstrument
# spell-checker:ignore (jargon) SHAs deps softprops toolchain
# spell-checker:ignore (names) CodeCOV MacOS MinGW Peltoche rivy llvm profraw
# spell-checker:ignore (shell/tools) choco clippy dmake dpkg esac fakeroot gmake grcov halium lcov libssl mkdir popd printf pushd rustc rustfmt rustup shopt xargs
# spell-checker:ignore (misc) aarch alnum armhf bindir busytest coreutils gnueabihf issuecomment maint nullglob onexitbegin onexitend runtest tempfile testsuite uutils

env:
  PROJECT_NAME: coreutils
  PROJECT_DESC: "Core universal (cross-platform) utilities"
  PROJECT_AUTH: "uutils"
  RUST_MIN_SRV: "1.43.1" ## v1.43.0

on: [push, pull_request]

jobs:
  coverage:
    name: Code Coverage
    runs-on: ${{ matrix.job.os }}
    strategy:
      matrix:
        # job: [ { os: ubuntu-latest }, { os: macos-latest }, { os: windows-latest } ]
        job:
          - { os: ubuntu-latest  , features: unix }
          - { os: macos-latest   , features: macos }
          - { os: windows-latest , features: windows }
    steps:
    - uses: actions/checkout@v1
    - name: Install/setup prerequisites
      shell: bash
      run: |
        ## install/setup prerequisites
        case '${{ matrix.job.os }}' in
          macos-latest) brew install coreutils ;; # needed for testing
        esac
    # - name: Reattach HEAD ## may be needed for accurate code coverage info
    #   run: git checkout ${{ github.head_ref }}
    - name: Initialize workflow variables
      id: vars
      shell: bash
      run: |
        ## VARs setup
        outputs() { for var in "$@" ; do echo steps.vars.outputs.${var}="${!var}"; echo ::set-output name=${var}::${!var}; done; }
        # toolchain
        TOOLCHAIN="nightly" ## default to "nightly" toolchain (required for certain required unstable compiler flags) ## !maint: refactor when stable channel has needed support
        # * specify gnu-type TOOLCHAIN for windows; `grcov` requires gnu-style code coverage data files
        case ${{ matrix.job.os }} in windows-*) TOOLCHAIN="$TOOLCHAIN-x86_64-pc-windows-gnu" ;; esac;
        # * use requested TOOLCHAIN if specified
        if [ -n "${{ matrix.job.toolchain }}" ]; then TOOLCHAIN="${{ matrix.job.toolchain }}" ; fi
        outputs TOOLCHAIN
        # staging directory
        STAGING='_staging'
        outputs STAGING
        ## # check for CODECOV_TOKEN availability (work-around for inaccessible 'secrets' object for 'if'; see <https://github.community/t5/GitHub-Actions/jobs-lt-job-id-gt-if-does-not-work-with-env-secrets/m-p/38549>)
        ## # note: CODECOV_TOKEN / HAS_CODECOV_TOKEN is not needed for public repositories when using AppVeyor, Azure Pipelines, CircleCI, GitHub Actions, Travis (see <https://docs.codecov.io/docs/about-the-codecov-bash-uploader#section-upload-token>)
        ## unset HAS_CODECOV_TOKEN
        ## if [ -n $CODECOV_TOKEN ]; then HAS_CODECOV_TOKEN='true' ; fi
        ## outputs HAS_CODECOV_TOKEN
        # target-specific options
        # * CARGO_FEATURES_OPTION
        CARGO_FEATURES_OPTION='--all-features' ;  ## default to '--all-features' for code coverage
        if [ -n "${{ matrix.job.features }}" ]; then CARGO_FEATURES_OPTION='--features "${{ matrix.job.features }}"' ; fi
        outputs CARGO_FEATURES_OPTION
        # * CODECOV_FLAGS
        CODECOV_FLAGS=$( echo "${{ matrix.job.os }}" | sed 's/[^[:alnum:]]/_/g' )
        outputs CODECOV_FLAGS
        COVERAGE_REPORT_DIR="target/debug"
        mkdir -p "${COVERAGE_REPORT_DIR}"
        COVERAGE_REPORT_DIR=$(realpath "target/debug")
        outputs COVERAGE_REPORT_DIR
        LLVM_PROFILE_FILE="${COVERAGE_REPORT_DIR}/coreutils-%p-%m.profraw"
        outputs LLVM_PROFILE_FILE
    - name: rust toolchain ~ install
      uses: actions-rs/toolchain@v1
      with:
        toolchain: ${{ steps.vars.outputs.TOOLCHAIN }}
        default: true
    - name: Initialize toolchain-dependent workflow variables
      id: dep_vars
      shell: bash
      run: |
        ## Dependent VARs setup
        outputs() { for var in "$@" ; do echo steps.vars.outputs.${var}="${!var}"; echo ::set-output name=${var}::${!var}; done; }
        # * determine sub-crate utility list
        UTILITY_LIST="$(./util/show-utils.sh ${CARGO_FEATURES_OPTION})"
        CARGO_UTILITY_LIST_OPTIONS="$(for u in ${UTILITY_LIST}; do echo "-puu_${u}"; done;)"
        outputs CARGO_UTILITY_LIST_OPTIONS
    - name: Test uucore
      uses: actions-rs/cargo@v1
      with:
        command: test
        args: ${{ steps.vars.outputs.CARGO_FEATURES_OPTION }} --no-fail-fast -p uucore
      env:
        RUSTFLAGS: "-Zinstrument-coverage"
        LLVM_PROFILE_FILE: ${{ steps.vars.outputs.LLVM_PROFILE_FILE }}
        # RUSTUP_TOOLCHAIN: ${{ steps.vars.outputs.TOOLCHAIN }}
    - name: Test
      uses: actions-rs/cargo@v1
      with:
        command: test
        args: ${{ steps.vars.outputs.CARGO_FEATURES_OPTION }} --no-fail-fast
      env:
        RUSTFLAGS: "-Zinstrument-coverage"
        LLVM_PROFILE_FILE: ${{ steps.vars.outputs.LLVM_PROFILE_FILE }}
        # RUSTUP_TOOLCHAIN: ${{ steps.vars.outputs.TOOLCHAIN }}
    - name: Test individual utilities
      uses: actions-rs/cargo@v1
      with:
        command: test
        args: ${{ steps.vars.outputs.CARGO_FEATURES_OPTION }} --no-fail-fast ${{ steps.dep_vars.outputs.CARGO_UTILITY_LIST_OPTIONS }}
      env:
        RUSTFLAGS: "-Zinstrument-coverage"
        LLVM_PROFILE_FILE: ${{ steps.vars.outputs.LLVM_PROFILE_FILE }}
        # RUSTUP_TOOLCHAIN: ${{ steps.vars.outputs.TOOLCHAIN }}
    - name: "`grcov` ~ install"
      uses: actions-rs/install@v0.1
      with:
        crate: grcov
        version: latest
        use-tool-cache: false
    - name: Generate coverage data (via `grcov`)
      id: coverage
      shell: bash
      env:
        COVERAGE_REPORT_DIR: ${{ steps.vars.outputs.COVERAGE_REPORT_DIR }}
      run: |
        rustup component add llvm-tools-preview
        # generate coverage data
        COVERAGE_REPORT_FILE="${COVERAGE_REPORT_DIR}/lcov.info"
        # GRCOV_IGNORE_OPTION='--ignore build.rs --ignore "/*" --ignore "[a-zA-Z]:/*"' ## `grcov` ignores these params when passed as an environment variable (why?)
        # GRCOV_EXCLUDE_OPTION='--excl-br-line "^\s*((debug_)?assert(_eq|_ne)?!|#\[derive\()"' ## `grcov` ignores these params when passed as an environment variable (why?)
        # generate coverage report
        grcov $COVERAGE_REPORT_DIR --binary-path ./target/debug/ --output-type lcov --branch --output-path "${COVERAGE_REPORT_FILE}" --ignore build.rs --ignore 'C:/Users/*' --ignore "/*" --ignore "[a-zA-Z]:/*" --excl-br-line "^\s*((debug_)?assert(_eq|_ne)?!|#\[derive\()"
        echo ::set-output name=report::${COVERAGE_REPORT_FILE}
    - name: Upload coverage results (to Codecov.io)
      uses: codecov/codecov-action@v1
      # if: steps.vars.outputs.HAS_CODECOV_TOKEN
      with:
        # token: ${{ secrets.CODECOV_TOKEN }}
        file: ${{ steps.coverage.outputs.report }}
        ## flags: IntegrationTests, UnitTests, ${{ steps.vars.outputs.CODECOV_FLAGS }}
        flags: ${{ steps.vars.outputs.CODECOV_FLAGS }}
        name: codecov-umbrella
        fail_ci_if_error: false
